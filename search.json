[{"title":"阿里百万级mq优秀源码学习","url":"/2018/10/11/阿里百万级mq优秀源码学习/","content":"> 阿里复赛以及学习的源码地址在：https://code.aliyun.com/250577914/queuerace2018\n\n### 思路\n> 学习优秀的源码首先需要学习编码者的思路风格。\n\n1. **确定文件读写方式**：mq的构建必须用到文件磁盘，那么对于IO的策略Java提供了三个方法：标准IO、NIO、Mmap。针对这个作者基于对当前优秀mq的源码为入口进行调研及实验，并结合当前应用场景进行分析\n2. **确定存储结构和索引结构**：mq中必然存在消息主体数据以及确定消息数据位置的索引数据。比赛规则要求存在对100w队列进行随机消费以及顺序消费。那么作者针对消息的消费场景决定**同一队列的消息尽可能存储在一起**，并通过**写缓冲区来减小IO次数**、**按块存储的稀疏索引降低索引文件数量**。\n> 为了能更高效的进行IO，我们不可能逐条的存取消息。而如何确定读写缓冲区大小以及缓冲区优化作者也给了一些思路。**如块读写**\n\n","tags":["读书笔记","学习"]},{"title":"关于SpringMVC的工作流程问题","url":"/2017/10/11/关于SpringMVC的工作流程问题/","content":"\n首先说明一下问题，之前遇到一个需求，是在springMVC中实现controller层的参数绑定。\n参数绑定意思就是：\n\n```\n@RequestMapping(value = \"/validator/test\", method = {RequestMethod.GET})\n@ResponseBody\n@FdMethodValidate\npublic String validatorModelControl(\n        @Min(10) @RequestParam(\"ten\") Integer ten,\n        @RequestParam(\"ignore\") Integer ignore,\n        @FdValidate  TestModel testModel, FdValidResult result) {\n    if (result.hasErrors()) {\n        List<FdValidError> lists = result.getErrors();\n        for (FdValidError row : lists) {\n            row.getErrorMessage();\n            LOGGER.error(row.getErrorMessage());\n        }\n    }\n    return \"success\";\n}\n```\n\n我希望在调用该接口之前先获取参数、进行逻辑操作、最后将输出结果绑定到FdValidResult中。\n\n最先想到的就是通过拦截器的在调用方法前进行预操作，并进行参数绑定。\n\n看起来好像很简单，实际上是却是一顿操作后打出了GG。\n \n\n---\n\n为什么会没有办法进行参数绑定，我门一步一步的调试这看。\n\n首先在不知道请求参数的情况下，如果要获取传递的参数则必须要提前调用参数解析器ArgumentResolver（为什么会说提前，后面会讲），所以拦截器的工作大致是：\n\n1. 获得参数签名\n2. 找出能够解析该参数的ArgumentResolver，\n3. 调用ArgumentResolver进行参数解析，流程是：\n    1. 如果为基本类型，则是RequestParamMapMethodArgumentResolver来进行解析。这一块具体细节没有太做研究，大致是从request的请求参数名称与参数签名进行匹配，最终返回的是基本类型的值。\n    2. 如果为ModelAttribute，则调用ModelAttributeMethodProcessor来进行解析。具体细节首先调用DataBinder将参数与Model属性进行绑定，同时还会进行数据校验（另一个坑）并叫校验结果BindResult存入ModelAndViewContainer中\n    3. 如果是BindResult类型，则调用ErrorsMethodArgumentResolver进行解析，它会从ModelAndViewContainer中尝试获取该类型，如果存在则返回该对象，否则抛出异常。\n```\npublic final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    String name = ModelFactory.getNameForParameter(parameter);\n    Object attribute = mavContainer.containsAttribute(name)?mavContainer.getModel().get(name):this.createAttribute(name, parameter, binderFactory, webRequest);\n    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n    if(binder.getTarget() != null) {\n        this.bindRequestParameters(binder, webRequest);\n        this.validateIfApplicable(binder, parameter);\n        if(binder.getBindingResult().hasErrors() && this.isBindExceptionRequired(binder, parameter)) {\n            throw new BindException(binder.getBindingResult());\n        }\n    }\n \n    Map<String, Object> bindingResultModel = binder.getBindingResult().getModel();\n    mavContainer.removeAttributes(bindingResultModel);\n    mavContainer.addAllAttributes(bindingResultModel);\n    return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n}\n```\n\n```\npublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    ModelMap model = mavContainer.getModel();\n    if(model.size() > 0) {\n        int lastIndex = model.size() - 1;\n        String lastKey = (String)(new ArrayList(model.keySet())).get(lastIndex);\n        if(lastKey.startsWith(BindingResult.MODEL_KEY_PREFIX)) {\n            return model.get(lastKey);\n        }\n    }\n \n    throw new IllegalStateException(\"An Errors/BindingResult argument is expected to be declared immediately after the model attribute, the @RequestBody or the @RequestPart arguments to which they apply: \" + parameter.getMethod());\n}\n```\n\n所以根据BindResult的解析逻辑，我只要将逻辑结果封装成一个DataBinder，并将其注入ModelAndViewContainer，貌似就完成了。\n\n当然没有那么简单，那么问题出现在哪里呢？\n\n从DispatchServlet开始走起：\n\n```\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n \n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n \n        try {\n            processedRequest = this.checkMultipart(request);\n            multipartRequestParsed = processedRequest != request;\n            mappedHandler = this.getHandler(processedRequest);\n            if(mappedHandler == null || mappedHandler.getHandler() == null) {\n                this.noHandlerFound(processedRequest, response);\n                return;\n            }\n \n            HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n            String method = request.getMethod();\n            boolean isGet = \"GET\".equals(method);\n            if(isGet || \"HEAD\".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if(this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n                }\n \n                if((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n \n            if(!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n \n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n            if(asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n \n            this.applyDefaultViewName(request, mv);\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        } catch (Exception var19) {\n            dispatchException = var19;\n        }\n \n        this.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    } catch (Exception var20) {\n        this.triggerAfterCompletion(processedRequest, response, mappedHandler, var20);\n    } catch (Error var21) {\n        this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var21);\n    } finally {\n        if(asyncManager.isConcurrentHandlingStarted()) {\n            if(mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        } else if(multipartRequestParsed) {\n            this.cleanupMultipart(processedRequest);\n        }\n \n    }\n \n}\n```\n\n前面通过HandlerMapping找到对应的Handler过程省略掉不关键，关键是我们能看到HanderAdpater执行handler之前会先拦截器的执行preHandle。\n\n那这又有什么关系呢？我们想起之前在prehandle进行操作的过程，期间再参数解析ArgumentResolve的时候使用了ModelAndViewContiner这个关键的容器。\n\n那我们再看继续调试，看看预处理后的HandlerAdapter怎么做处理，继续一步一步调试，然后最终会执行RequestMappingHandlerAdapter这个实现类的这个方法：\n\n```\nprivate ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);\n    ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);\n    ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);\n    ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n    modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);\n    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n    asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.setTaskExecutor(this.taskExecutor);\n    asyncManager.setAsyncWebRequest(asyncWebRequest);\n    asyncManager.registerCallableInterceptors(this.callableInterceptors);\n    asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n    if(asyncManager.hasConcurrentResult()) {\n        Object result = asyncManager.getConcurrentResult();\n        mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];\n        asyncManager.clearConcurrentResult();\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Found concurrent result value [\" + result + \"]\");\n        }\n \n        requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);\n    }\n \n    requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);\n    return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);\n}\n```\n\n\n看到这里就明白了，无论你在拦截器中如何定义DataBinder如何声明ModelAndViewContainer容器，在拦截器执行后执行Handler时都会被重置。这就是在拦截器不可能进行参数绑定的原因，因为拦截器的执行要先于HandlerAdapter的执行的。\n\n---\n\n最后附一张到来的SpringMVC的执行流程图，加深一下印象：\n![image](http://neoremind.com/wp-content/uploads/060828381f30e92466d592d34e086e061c95f7db.png)\n\n个人理解，欢迎讨论","tags":["java","经验总结"]}]